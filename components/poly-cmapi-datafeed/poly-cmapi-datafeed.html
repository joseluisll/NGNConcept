

<!-- Imports polymer -->
<link rel="import" href="../../bower_components/polymer/polymer.html">


<!-- Defines element markup -->
<dom-module id="poly-cmapi-datafeed" attributes="url layer_id format">

    <style>
        :host { display: block; }
        :host #cmapi-datafeed {height:0%; width:0%}
    </style>

    <template>
        <!-- local DOM for your element -->
        <div id="poly-cmapi-datafeed-content">
            <iron-ajax id="ajax_requester"
                    auto
                    url="http://localhost:800/http://krk.data.fr24.com/zones/fcgi/feed.js?bounds=82.74652281376211,-83.44892683138465,5744.8828125,491.8359375&faa=1&mlat=0&flarm=0&adsb=0&gnd=0&air=1&vehicles=0&estimated=1&maxage=3600&gliders=0&stats=1"
                    handle-as="text"
                    on-response="_handleResponse"
                    debounce-duration="300">

            </iron-ajax>
        </div>
    </template>

    <!-- CMAPI v.1.3 script and schema -->
    <script src="../../libs/cmapi/dist/tv4.js"></script>
    <script src="../../libs/cmapi/dist/cmapi.schema.js"></script>
    <script src="../../libs/cmapi/dist/cmajs.js"></script>
    <script src="../../libs/cmapi/dist/cmapi.examples.js"></script>
    <script src="../../bower_components/httpclient/dist/HTTPClient.js"></script>

    <!-- Registers custom element -->
    <script>
        "use strict";

        Polymer({
            is: 'poly-cmapi-datafeed',

            //behaviors: [],
            //listeners: [],


            <!-- PUBLIC PROPERTIES -->
            properties: {
                url: {
                    //THIS PROPERTY WILL BE USED TO CONFIGURE THE IRON_AJAX COMPONENT, WHICH IS THE XHR FETCHER!!!. ALSO, THE USE OF A PROXY COULD BE PARAMETERIZED, TO BYPASS A CROSS-DOMAIN EXCHANGE.
                    //TODO: CONNECT THE IRON_AJAX COMPONENT TO DETECT THE CHANGE ON THE URL, SO THAT IT GRABS THE NEW DATA
                    type:String,
                    value:'http://krk.data.fr24.com/zones/fcgi/feed.js?bounds=82.74652281376211,-83.44892683138465,5744.8828125,491.8359375&faa=1&mlat=0&flarm=0&adsb=0&gnd=0&air=1&vehicles=0&estimated=1&maxage=3600&gliders=0&stats=1'
                },
                //THIS PROPERTY WILL BE USED AS THE OVERLAY_ID IN THE MAP.FEATURE.PLOT AND UPDATE MESSAGES!!!
                //TODO: ADD CODE FOR DETECTING CHANGES OF THE LAYER ID. THIS PARAMETER SHOULD BE CONFIGURABLE BY THE USER.
                layer_id:{
                    type:String,
                    value:'UNKNOWN_YET'
                },
                //THIS PROPERTY WILL BE USED AS THE format of the feature IN THE MAP.FEATURE.PLOT AND UPDATE MESSAGES!!!
                //TODO: ADD CODE FOR DETECTING CHANGES OF THE format type. THIS PARAMETER SHOULD BE CONFIGURABLE BY THE USER.
                format:{
                    type:String,
                    value:'geojson'
                    /*EXTRACT FROM THE OL3 3.5 API DOCUMENT FOR ol.format
                    *   EsriJSON
                    *   Feature
                    *   GeoJSON
                    *   GML
                    *   GML2
                    *   GML3
                    *   GMLBase
                    *   GPX
                    *   IGC
                    *   JSONFeature
                    *   KML
                    *   OSMXML
                    *   Polyline
                    *   TextFeature
                    *   TopoJSON
                    *   WFS
                    *   WKT
                    *   WMSCapabilities
                    *   WMSGetFeatureInfo
                    *   WMTSCapabilities
                    *   XML
                    *   XMLFeature
                    *
                    *CMAPI 1.3RC4 ONLY SPECIFIES FOR THE PLOT MESSAGE {
                    *   overlayId: string (optional),
                    *   featureId: string (required),
                    *   name: string (optional),
                    *   format: string ["kml", "geojson"] default="kml" (optional),
                    *   feature: object | string (required),
                    *   zoom: boolean default=false (optional),
                    *   readOnly: boolean default=true (optional),
                    *   properties: object (optional)
                    *}
                    *
                     */


                }


            },

            <!-- INTERNAL PROPERTIES -->
            _data_feed:{
                type:Object,
                value:null
            },
            _cmajs: {
                type:Object,
                value:null
            },




            <!--   INTERNAL FUNCTIONS EVENTS  -->




            <!--      LYFECYCLE EVENTS  -->
            ready: function() {
                this._data_feed=[];


                console.debug('CMAPI DATAFEED Ready Event executing.');

            },

            created: function() {
                console.log('CMAPI DATAFEED Event created executed.');
            },

            attached: function() {
                console.log('CMAPI DATAFEED Event attached executed.');



            },

            detached: function() {
                console.log('CMAPI DATAFEED Event detached executed.');

            },

            attributeChanged: function(name, type) {
                console.log('CMAPI DATAFEED Event attributeChanged executed.');

            },

            _handleResponse: function(e) {
                var self = document.querySelector('#cmapi-datafeed');
                //{"full_count":9433,"version":4
                var PATTERN_TOTAL='"version":4';
                var PATTERN_STATS= ',"stats":{"total":{"';
                var PATTERN_RECORD='\n';
                var PATTERN_RECORD_DATA=':';

                //clean up initial header: the total of records...
                var data=e.detail.response.toString().split(PATTERN_TOTAL);
                data=data[1];//discard the total and version header...

                //clean up stats header: the total of records... actually returned, different from the total.
                var data=data.split(PATTERN_STATS);
                data=data[0];//discard the stats info.

                //LETS DO SOME CUTTING AND PASTING
                var aircraft=[];
                data=data.split(PATTERN_RECORD);

                var counter=0;
                var aircraft_attributes=null;
                var index=0;
                var offset=this._data_feed.length;

                while(true) {

                    data[counter]=data[counter].substring(1,data[counter].length); //cut initial coma
                    aircraft_attributes=data[counter].split(PATTERN_RECORD_DATA);
                    aircraft[counter]={};
                    aircraft[counter].id=aircraft_attributes[0];
                    aircraft[counter].attributes=JSON.parse(aircraft_attributes[1]);
                    //check if the aircraft already exists?

                    var index=this._exists(aircraft[counter]);
                    if(index>=0) {//ya existe, no hace falta anadirlo sino actualizar los atributos del avion
                        this._data_feed[index].attributes=aircraft[counter].attributes;
                        if(window.cmapi===undefined)  {//if we are in standalone mode, do nothing...

                        }else { //if we are in integrated mode, then send the cmapi message
                            this._CMAPI_map_feature_update(aircraft[counter]);
                        }
                        continue;
                    }

                    //el avion no existe, se anade...
                    this._data_feed[counter+offset]=aircraft[counter];


                    //SEND A CMAPI FEATURE ADD!!!!

                    if(window.cmapi===undefined)  {//if we are in standalone mode, do nothing...

                    }else { //if we are in integrated mode, then send the cmapi message
                        this._CMAPI_map_feature_plot(aircraft[counter]);
                    }

                    //store the aircraft data into the internal array
                    //this._data_feed[aircraft.id]=aircraft;
                    counter++;
                    if(data[counter+1]===undefined) break;
                }
                console.log('Processed '+ counter+' Aircrafts');

                //var child=document.createElement('p');
                //child.innerText=JSON.stringify(e.detail.response);
                //Polymer.dom( self.root).appendChild(child);
                setTimeout(function() {
                    document.querySelector('#ajax_requester').setAttribute("body",Math.random().toString());
                },30000);
            },
            _exists:function (what){
                var index=0;
                var result=-1;

                if(what===undefined) return -1;
                if(!what.hasOwnProperty('id')) return -1;
                if(!what.hasOwnProperty('attributes')) return -1;

                for (index in this._data_feed) {
                    if(this._data_feed[index].id===what.id) {
                        result=index;
                    }
                }

                return result;
            },
            _CMAPI_map_feature_plot: function (what) {
                //TODO: ADD ERROR HANDLING FOR THE WHAT.


                var payload={
                    //TODO: THE LAYER_ID MUST BE A CONFIGURABLE PARAMETER OF THE DATAFEED COMPONENT. ALSO, THE OL3MAP SHOULD DEAL WITH THE PROBLEM WHEN THE LAYER DOES NOT EXIST YET. IT WILL BE AUTOMATICALLY CREATED.
                    "overlayId":this.layer_id,
                    "featureId":cmajs.utils.getUUID(), //WHEN CREATING A FEATURE, THE ID SHOULD BE RANDOM AND UNIQUE?
                    "format":this.format,                 //TODO: FORMAT FOR FEATURES SHOULD BE CONFIGURABLE AND ATTRIBUTE OF THE COMPONENT. GEOJSON AS THE DEFAULT.
                    "crs": {
                        "type": 'name',
                        "properties": {
                            "name": 'EPSG:4326'           //LAT LONG MANDATED BY CMAPI
                        }
                    },
                    "feature":{
                        "type":"Feature",
                        "geometry":{
                            "type":"point",
                            "coordinates":[             //OBTAINED BY THE DATA_FEED.
                                what.attributes[1],//0 is registration number, 1 is the lat, 2 is long;
                                what.attributes[2]
                            ]
                        }
                    }
                };

                var plotmsg = {
                    channel: "map.feature.plot",
                    message: payload
                };
                console.debug(JSON.stringify(plotmsg));
                if(this._cmajs!=undefined)
                var bol=this._cmajs.runtimes.browser.pubSub.publish(plotmsg);

            },
            _CMAPI_map_feature_update: function (what) {
                //what is a copy of the object that contains the data. In this case, id and array of attributes.
            }


        });
    </script>

    <script src="poly-cmapi-datafeed.js"></script>

</dom-module>